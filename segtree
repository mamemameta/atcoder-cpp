struct segtree {
	struct X{
		ll x=0;//長さ
		X(ll _x):x(_x){;}
		X():x(0){;}
		bool operator==(X r) {re r.x==x;}
	};
	X opx(X x1,X x2)
	{
		return max(x1.x,x2.x);
	}
	X ex=X(0);
	using FX = function<X(X, X)>;
	int n;
	vector<X> dat;
	segtree(int n_):dat(n_*4,ex){
			int x = 1;
			while (n_ > x) x *= 2;
			n = x;
			//fl("n",n);
	}

	void set(int i, X x) { dat[i + n - 1] = x; }
	void build() {
		for (int k = n - 2; k >= 0; k--) dat[k] = opx(dat[2 * k + 1], dat[2 * k + 2]);
	}
	void update(int i, X x) {
		i += n - 1;
		dat[i] = x;
		while (i > 0) {
			i = (i - 1) / 2;  // parent
			dat[i] = opx(dat[i * 2 + 1], dat[i * 2 + 2]);
		}
	}
	X query_sub(int a, int b, int k, int l, int r) {
		if (r <= a || b <= l) {  // 完全に外側の時
			return ex;
		} else if (a <= l && r <= b) {  // 完全に内側の時
			return dat[k];
		} else {  // 一部区間が被る時
			X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
			X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
			return opx(vl, vr);
		}
	}
	X query(int a, int b) { return query_sub(a, b, 0, 0, n); }
};
