
/* SegTreeLazy<X,M>(n,fx,fa,fm,ex,em): モノイド(集合X, 二項演算fx,fa,fm, 単位元ex,em)についてサイズnで構築
    set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)
    update(l,r,x): [l,r) O(log(n))
    query(a,b):  [a,b) 全てにfxを作用させた値を取得。O(log(n))
struct lazy {
	struct X{
		//a*x+b;
		ll x;
		X(ll _x):x(_x){;}
		bool operator==(X r) {re r.x==x;}
	};
	struct A
	{
		ll a;
		A(ll _a):a(_a){;}
		bool operator==(A r) {re a==r.a;}
	};
	X opx(X x1,X x2)
	{
		return x1.x+x2.x;
	}
	X ex=X(0ll);
	X opax(A a,X x)
	{
		return a.a+x.x;
	}
	A opa(A a1,A a2)
	{
		A a=a1;
		a.a+=a2.a;
		return a;
	}
	A ea=A(0ll);
	using FX = function<X(X, X)>;
	using FAX = function<X(A,X)>;
	using FA = function<A(A, A)>;
	int n;
	vector<X> dat;
	vector<A> v_lazy;
	lazy(int n_):dat(n_*4,ex),v_lazy(n_*4,ea){
			int x = 1;
			while (n_ > x) x *= 2;
			n = x;
			//fl("n",n);
	}

	void set(int i, X x) { dat[i + n - 1] = x; }
	void build() {
		for (int k = n - 2; k >= 0; k--) dat[k] = opx(dat[2 * k + 1], dat[2 * k + 2]);
	}

	/* lazy eval 
	void eval(int k) {
		if (v_lazy[k] == ea) return;  // 更新するものが無ければ終了
		if (k < n - 1) {            // 葉でなければ子に伝搬
			v_lazy[k * 2 + 1] = opa(v_lazy[k * 2 + 1], v_lazy[k]);
			v_lazy[k * 2 + 2] = opa(v_lazy[k * 2 + 2], v_lazy[k]);
		}
		// 自身を更新
		dat[k] = opax(v_lazy[k],dat[k]);
		v_lazy[k] = ea;
	}

	void update(int a, int b, A x, int k, int l, int r) {
		eval(k);
		if (a <= l && r <= b) {  // 完全に内側の時
			v_lazy[k] = opa(v_lazy[k], x);
			eval(k);
		} else if (a < r && l < b) {                     // 一部区間が被る時
			update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子
			update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子
			dat[k] = opx(dat[k * 2 + 1], dat[k * 2 + 2]);
		}
	}
	void update(int L, int R, A a) { update(L, R, a, 0, 0, n); }
	void update(int L, int R, ll a) { 
		A Aa=A(a);
		update(L, R, Aa, 0, 0, n); }

	X query_sub(int a, int b, int k, int l, int r) {
		eval(k);
		if (r <= a || b <= l) {  // 完全に外側の時
			return ex;
		} else if (a <= l && r <= b) {  // 完全に内側の時
			return dat[k];
		} else {  // 一部区間が被る時
			X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
			X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
			return opx(vl, vr);
		}
	}
	X query(int a, int b) { return query_sub(a, b, 0, 0, n); }
};
/* SegTreeLazy<X,M>(n,fx,fa,fm,ex,em): モノイド(集合X, 二項演算fx,fa,fm, 単位元ex,em)についてサイズnで構築
    set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)
    update(l,r,x): [l,r) O(log(n))
    query(a,b):  [a,b) 全てにfxを作用させた値を取得。O(log(n))
