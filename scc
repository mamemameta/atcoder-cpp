struct SCC {
	using Edge = int;
	using SGraph = vector<vector<Edge>>;

	// input
	SGraph D, rD;

	// result
	vector<vector<int>> cmp;//連結成分の配列
	vector<int> par;//vがどの連結成分に属するか
	SGraph dag;  //新たに作成されたdag

	// constructor
	SCC(int N) : D(N), rD(N) {}

	// add edge
	void addedge(int u, int v) {
		D[u].push_back(v);
		rD[v].push_back(u);
	}

	// decomp
	vector<bool> seen;
	vector<int> vs, rvs;
	void dfs(int v) {
		seen[v] = true;
		for (auto head : D[v]) if (!seen[head]) dfs(head);
		vs.push_back(v);
	}
	void rdfs(int v, int k) {
		seen[v] = true;
		par[v] = k;
		for (auto e : rD[v]) if (!seen[e]) rdfs(e, k);
		rvs.push_back(v);
	}

	// reconstruct
	set<pair<int,int>> newEdges;
	void reconstruct() {
		int N = (int)D.size();
		int dV = (int)cmp.size();
		dag.assign(dV, vector<Edge>());
		newEdges.clear();
		for (int i = 0; i < N; ++i) {
			int u = par[i];
			for (auto e : D[i]) {
				int v = par[e];
				if (u == v) continue;
				if (!newEdges.count({u, v})) {
					dag[u].push_back(v);
					newEdges.insert({u, v});
				}
			}
		}
	}

	// main
	void build() {
		// first dfs
		int N = (int)D.size();
		seen.assign(N, false);
		vs.clear();
		for (int v = 0; v < N; ++v) if (!seen[v]) dfs(v);

		// back dfs
		int k = 0;
		cmp.clear();
		par.assign(N, -1);
		seen.assign(N, false);
		for (int i = N - 1; i >= 0; --i) {
			if (!seen[vs[i]]) {
				rvs.clear();
				rdfs(vs[i], k++);
				cmp.push_back(rvs);
			}
		}

		// reconstruct
		reconstruct();
	}
};
